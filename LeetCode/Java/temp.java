import java.util.*;

/**
 * Definition for ListNode.
 * public class ListNode {
 *     int val
 *     ListNode next;
 *     ListNode(int val) {
 *         this.val = val;
 *         this.next = null;
 *     }
 * }
 */
public class temp {
  public List<String> addOperators(String num, int target) {
    List<String> ans = new ArrayList<>();
    if (num == null || num.length() < 2) {
      return ans;
    }
    StringBuilder sb = new StringBuilder(num);
    dfsHelper(sb, target, 1, ans);

    return ans;
  }

  private void dfsHelper(StringBuilder sb, int target, int pos, List<String> ans) {
    if (pos >= sb.length()) {
      String str = sb.toString();
      if (calculate(str) == target) {
        ans.add(str);
      }
      return;
    }

    char[] operators = {'+', '-', '*'};

    for (int i = pos; i < sb.length(); i++) {
      for (int j = 0; j < 3; j++) {
        sb.insert(i, operators[j]);
        dfsHelper(sb, target, i + 2, ans);
        sb.deleteCharAt(i);
      }
    }
  }

  private long calculate(String str) {
    Stack<Character> operators = new Stack<>();
    Stack<Long> operands = new Stack<>();

    for (int i = 0; i < str.length(); i++) {
      char cur = str.charAt(i);
      if (Character.isDigit(cur)) {
        int j = i + 1;
        while (j < str.length() && Character.isDigit(str.charAt(j))) {
          j++;
        }
        operands.push(Long.parseLong(str.substring(i, j)));
        i = j - 1;
      } else {
        if (operators.isEmpty()) {
          operators.push(cur);
        } else if (operators.peek() == '+' || operators.peek() == '-') {
          operators.push(cur);
        } else {
          if (cur != '*'){
            while (!operators.isEmpty() && operators.peek() == '*') {
              operands.push(op(operators.pop(), operands.pop(), operands.pop()));
            }
          }

          operators.push(cur);
        }
      }
    }

    while (!operators.isEmpty()) {
      operands.push(op(operators.pop(), operands.pop(), operands.pop()));
    }

    return operands.pop();
  }

  private long op(char operator, long a, long b) {
    if (operator == '+') {
      return b + a;
    } else if (operator == '-') {
      return b - a;
    } else {
      return b * a;
    }
  }

  public void removeDuplicate(List<String> a, List<String> b) {
    for (int i = 0; i < b.size(); i++) {
      String temp = b.get(i);
      if (a.contains(temp)) {
        b.remove(temp);
        a.remove(temp);
        i--;
      }
    }
  }




  public static void main(String[] args) {
    String[] temp = {"oath", "pea", "eat", "rain"};
    char[][] board = {
        {'o', 'a', 'a', 'n'},
        {'e', 't', 'a', 'e'},
        {'i', 'h', 'k', 'r'},
        {'o', 'f', 'l', 'v'}
    };

    Set<String> dict = new HashSet<String>();

    for (int i = 0; i < temp.length; i++) {
      dict.add(temp[i]);
    }

    String[] strA = {"1 + 1", " 2-1 + 2", "(1 + (4+5+2)-3) + (6+8)"};
    int i = 0;


    char[][] sodoku = {{'X', 'X', 'X', 'X'},
        {'X', 'O', 'O', 'X'},
        {'X', 'X', 'O', 'X'},
        {'X', 'O', 'X', 'X'}};
    int[] A = {3, 2, 1, 3, 3, 3, 5, 6, 3, 7};
    int[] BB = {5, 6, 7, 3, 2, 1, 0};
    int[][] matrix1 = {{1,1,1,1,1,1,1,1,1,1,1,-10,1,1,1,1,1,1,1,1,1,1,1}};

    TreeNode root = new TreeNode(1);
    root.left = new TreeNode(2);
    root.right = new TreeNode(5);
    root.left.left = new TreeNode(3);
    root.left.right = new TreeNode(4);
    root.right.right = new TreeNode(6);
    TreeLinkNode tln = new TreeLinkNode(1);
    tln.left = new TreeLinkNode(2);
    tln.right = new TreeLinkNode(3);
    tln.left.left = new TreeLinkNode(4);
    tln.left.right = new TreeLinkNode(5);
    tln.right.right = new TreeLinkNode(7);


    List<Interval> test = new ArrayList<>();
    test.add(new Interval(1, 2));
    test.add(new Interval(3, 5));
    test.add(new Interval(6, 7));
    test.add(new Interval(8, 10));
    test.add(new Interval(12, 16));
    Queue<Set<String>> myQueue = new LinkedList<>();

    ArrayList<Integer> B = new ArrayList<Integer>();
    for (int n: A) {
      B.add(n);
    }
//    Point[] pts= {new Point(0, 0), new Point(0, 1), new Point(2, 2), new Point(2, 1)};
//
//    ListNode head = new ListNode(4);
//    head.next = new ListNode(3);
//    head.next.next = new ListNode(1);
//    head.next.next.next = new ListNode(5);
//    head.next.next.next.next = new ListNode(2);
    boolean check = dict.contains("hot");
    String[] words = {"This", "is", "an", "example", "of", "text", "justification."};
    int[] pre = {1, 2, 5, 6, 3, 7, 8};
    int[] in = {5, 2, 6, 1, 7, 3, 8};
    int[] post = {5, 6, 2, 7, 8, 3, 1};
    ArrayList<Interval> quries = new ArrayList<>();
    quries.add(new Interval(1, 2));
    quries.add(new Interval(0, 4));
    quries.add(new Interval(2, 4));
    int[] col = new int[1000];

    List<Integer> a1 = new ArrayList<>(B);
    List<Integer> a2 = new ArrayList<>(B);
    List<String> a = new ArrayList<>(Arrays.asList(
        "1*2*3*4*5-6+78-9","1*2*3*4+5+6-7-8+9","1*2*3+4+5+6+7+8+9","1*2*3+4+5-6*7-8*9","1*2*3+4-5*6+7-8*9","1*2*3+4-5*6-7*8+9","1*2*3-4*5+6+7-8*9","1*2*3-4*5+6-7*8+9","1*2*3-4*5-6*7+8+9","1*2*3-45-67+8+9","1*2*34+56-7+8*9","1*2*34-5-6-7+8+9","1*2+3*4-56-78+9","1*2+3+4+5*6+7+8-9","1*2+3+4-5+6-7*8-9","1*2+3+4-5-6*7+8-9","1*2+3+45+67-8*9","1*2+3-45-6+7+8*9","1*2+34+5-6+7-8+9","1*2+34+56-7*8-9","1*2+34-5-6+7-8-9","1*2+34-56+7-8*9","1*2+34-56-7*8+9","1*2-3*4-5+67-8+9","1*2-3+4*5-67+8-9","1*2-3+4-56-7+8-9","1*2-3-4-5+6*7-89","1*2-34-5*6+7*8-9","1*23+4*5-6-7-8-9","1*23-4+56+7-89","1+2*3*4*5+6+7-89","1+2*3*4+5*6+7-8+9","1+2*3*4-5-6*7-8+9","1+2*3+4*5*6+7-89","1+2*3+4*5-6-7+8+9","1+2*3-4+5+6*7-89","1+2*34-5*6-7+8-9","1+2+3*4*5+6-7+8+9","1+2+3*4+5+6*7-8+9","1+2+3*45-6+78+9","1+2+3+4+5+6+7+8+9","1+2+3+4+5-6*7-8*9","1+2+3+4-5*6+7-8*9","1+2+3+4-5*6-7*8+9","1+2+3-4*5+6+7-8*9","1+2+3-4*5+6-7*8+9","1+2+3-4*5-6*7+8+9","1+2+3-45-67+8+9","1+2-3*4*5-6+7+89","1+2-3*4+5+6+7-8*9","1+2-3*4+5+6-7*8+9","1+2-3*4+5-6*7+8+9","1+2-3*4-5*6+7+8+9","1+2-3+4+5*6-7+8*9","1+2-3+45+6-7+89","1+2-3-4*5+6*7-8+9","1+2-3-45+6-7+8-9","1+2-3-45-6-7+8-9","1+2-34+5+6-78+9","1+2-34-5+6+7*8+9","1+2-34-5+6-7-8*9","1+23*4+5-6+7*8-9","1+23*4-5+6*7-8-9","1+23*4-56-7-8-9","1+23+4+5+6+7+8-9","1+23+4-5*6-7*8-9","1+23+4-5+67-89","1+23-4*5+6-7*8-9","1+23-4*5-6*7+8-9","1+23-4+5+6*7-8*9","1+23-4+5-6+7+8+9","1+23-45-67+8-9","1-2*3*4+5+6-7+8*9","1-2*3*4-5-6-78-9","1-2*3+4+5+6+7-8*9","1-2*3+4+5+6-7*8+9","1-2*3+4+5-6*7+8+9","1-2*3+4-5*6+7+8+9","1-2*3-4*5+6+7+8+9","1-2*3-4*5-6*7-8*9","1-2*3-4+5+6*7+8-9","1-2*3-4+5-6-7*8-9","1-2*3-4+56+7-8+9","1-2*3-45-67-8*9","1-2*34-5*6-7-89","1-2+3*4+5+6-78-9","1-2+3*4-5+6+7*8-9","1-2+3-4-5-67-8+9","1-2+3-45-6+7-8+9","1-2+34+5-6+7+8*9","1-2+34-5+6+78-9","1-2+34-56+7+8+9","1-2-3*4*5-6+7-8-9","1-2-3+4-5*6-78-9","1-2-3+45+6-7-8-9","1-2-3-4*5+6-78-9","1-2-3-45-6-7-89","1-23*4-5+6*7+89","1-23+4+5+6+7-89","1-23+4-5+67+8-9","1-23-4*5-6*7-89","1-23-4-5-67-8-9","1-23-45-67-89","12*3*4-5*6+78-9","12*3+4+5+6-7+8-9","12*3+4+5-6-7+8-9","12*3-4+5+6-7+8+9","12*3-4+56-78-9","12+3*4+5+6-7-8+9","12+3*45-6+7+89","12+3+4-56+7-89","12+3-4*5-67-8+9","12+3-45-6+78-9","12+34-5+6+7-8+9","12-3*4*5-6+78+9","12-3*4+5-67-8+9","12-3+4+56-7+89","12-3+4-5*6-7-8+9","12-3+45+6-78+9","12-3-4*5+6-7-8+9","12-3-4+56-7+8+9"
    ));
    List<String> b = new ArrayList<>(Arrays.asList(
        "1*2*3*4*5-6-78+9","1*2*3*4+5+6-7+8+9","1*2*3+4+5+6+7+8+9","1*2*3+4+5-6*7+8*9","1*2*3+4-5*6+7*8+9","1*2*3+4-5*6-7+8*9","1*2*3-4*5+6*7+8+9","1*2*3-4*5-6+7*8+9","1*2*3-4*5-6-7+8*9","1*2*3-45+67+8+9","1*2*34+56-7-8*9","1*2*34-5+6-7-8-9","1*2+3*4-56+78+9","1*2+3+4+5*6+7+8-9","1*2+3+4-5+6*7+8-9","1*2+3+4-5-6+7*8-9","1*2+3+45+67-8*9","1*2+3-45+6+7+8*9","1*2+34+5-6-7+8+9","1*2+34+56-7*8+9","1*2+34-5+6+7-8+9","1*2+34-56+7*8+9","1*2+34-56-7+8*9","1*2-3*4+5+67-8-9","1*2-3+4-5-6*7+89","1*2-3-4*5+67+8-9","1*2-3-4+56-7-8+9","1*2-34+5*6+7*8-9","1*23+4*5-6+7-8+9","1*23-4-56-7+89","1+2*3*4*5+6+7-89","1+2*3*4+5*6+7-8-9","1+2*3*4-5+6*7-8-9","1+2*3+4*5*6+7-89","1+2*3+4*5-6+7+8+9","1+2*3-4-5-6*7+89","1+2*34-5*6+7+8-9","1+2+3*4*5+6-7-8-9","1+2+3*4+5+6*7-8-9","1+2+3*45-6-78-9","1+2+3+4+5+6+7+8+9","1+2+3+4+5-6*7+8*9","1+2+3+4-5*6+7*8+9","1+2+3+4-5*6-7+8*9","1+2+3-4*5+6*7+8+9","1+2+3-4*5-6+7*8+9","1+2+3-4*5-6-7+8*9","1+2+3-45+67+8+9","1+2-3*4*5+6+7+89","1+2-3*4+5*6+7+8+9","1+2-3*4-5+6*7+8+9","1+2-3*4-5-6+7*8+9","1+2-3*4-5-6-7+8*9","1+2-3+4*5+6*7-8-9","1+2-3+45+6-7-8+9","1+2-3+45-6+7+8-9","1+2-3-4-5*6+7+8*9","1+2-3-45-6+7+89","1+2-34+5+6+7*8+9","1+2-34+5+6-7+8*9","1+2-34-5-6+78+9","1+23*4+5-6-7*8+9","1+23*4-5-6*7+8-9","1+23*4-56+7-8+9","1+23+4+5+6+7+8-9","1+23+4-5*6+7*8-9","1+23+4-5-67+89","1+23-4*5+6*7+8-9","1+23-4*5-6+7*8-9","1+23-4-5+6+7+8+9","1+23-4-5-6*7+8*9","1+23-45+67+8-9","1-2*3*4+5-6+78-9","1-2*3*4-5-6+7+8*9","1-2*3+4*5+6+7+8+9","1-2*3+4*5-6*7+8*9","1-2*3+4+5+6*7+8-9","1-2*3+4+5-6+7*8-9","1-2*3+4+56+7-8-9","1-2*3+45-67+8*9","1-2*3-4+5*6+7+8+9","1-2*3-4-5+6*7+8+9","1-2*3-4-5-6+7*8+9","1-2*3-4-5-6-7+8*9","1-2*34+5*6-7+89","1-2+3*4*5-6-7+8-9","1-2+3+4-5*6+78-9","1-2+3+45+6-7+8-9","1-2+3-4*5-6+78-9","1-2+3-45+6-7+89","1-2-3*4+5+6+7*8-9","1-2-3*4-5-6+78-9","1-2-3+4-5+67-8-9","1-2-3+45-6-7+8+9","1-2-34+5+6+78-9","1-2-34+56+7+8+9","1-2-34-5+6+7+8*9","1-23*4+5+6*7+89","1-23+4*5-6*7+89","1-23+4-5+67-8+9","1-23+45-67+89","1-23-4+5+67+8-9","1-23-4-5-6-7+89","12*3*4-5*6-78+9","12*3+4+5+6-7-8+9","12*3+4+5-6+7+8-9","12*3-4-5-6+7+8+9","12*3-4-56+78-9","12+3*4+5+6-7+8+9","12+3*45-6-7-89","12+3+4-56-7+89","12+3-4*5+67-8-9","12+3-45+6+78-9","12+34-5-6-7+8+9","12-3*4*5+6+78+9","12-3*4-5+67-8-9","12-3+4*5+6-7+8+9","12-3+4+56-7-8-9","12-3-4+5*6-7+8+9","12-3-4-56+7+89","12-3-45-6+78+9"
    ));
    new temp().removeDuplicate(a, b);
    return;
  }
}

